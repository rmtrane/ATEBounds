---
title: "Bounds using Bivariate Data"
description: "Obtaining bounds on the ACE using bivariate data."
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Bounds from Bivariate Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Here we will see how bounds on the ACE behaves when derived from a single IV in bivariate data. We know that the width of the bounds is bounded above by $2\cdot (1 - ST_X)$, when monotonicity of the effect of $Z$ on both $X$ and $Y$ holds. Here, we will see throught simulations, that the same is the case without these assumptions. 

## Generate Distributions

We will consider IVs that take three levels. To generate values of $P(X = 1 | Z = z)$ we simply choose three values from a uniform distribution. The matrices obtained from the polymake program give us some constraints on the values of $P(Y = 1 | Z = z)$. These are included below. 

```{r echo = FALSE}
library(tidyverse, quietly = TRUE)
ACEBounds:::matrices_from_polymake %>% 
  filter(!x_monotone, !y_monotone,
         data_format == "bivariate", 
         n_z_levels == 3) %>% 
  pull(matrix) %>% .[[1]] %>% 
  filter(alpha == 0) %>%
  select(where(~sum(abs(.x)) > 0)) %>%
  filter(rowSums(abs(.)) > 1) %>% 
  pander::pander()
```


The function `simulate_gammas_from_thetas` takes a vector of length 3 of values of $P(X = 1 | Z = z)$, and returns a vector of length 3 of values of $P(Y = 1 | Z = z)$ such that no constraint is violated.

```{r}
simulate_gammas_from_thetas <- function(thetas){

  gammas <- vector(length = length(thetas))


  gammas[1] <- runif(1)

  gammas[2] <- runif(1,
                     min = max(0,
                               gammas[1] - thetas[1] - thetas[2], # row 3
                               gammas[1] + thetas[1] + thetas[2] - 2), # row 5
                     max = min(1,
                               gammas[1] - thetas[1] - thetas[2] + 2, # row 11
                               gammas[1] + thetas[1] + thetas[2]) # row 16
                     )

  gammas[3] <- runif(1,
                     min = max(0,
                               gammas[1] - thetas[1] - thetas[3], # row 4
                               gammas[1] + thetas[1] + thetas[3] - 2, # row 6
                               gammas[2] - thetas[2] - thetas[3], # row 12
                               gammas[2] + thetas[2] + thetas[3] - 2), # row 9
                     max = min(1,
                               gammas[2] - thetas[2] - thetas[3] + 2, # row 10
                               gammas[2] + thetas[2] + thetas[3], # row 13
                               gammas[1] - thetas[1] - thetas[3] + 2, # row 17
                               gammas[1] + thetas[1] + thetas[3])) # row 15
  return(gammas)
}
```

We generate $10,000$ sets of distributions.

```{r}
library(tidyverse)
library(ACEBounds)

set.seed(7226637)
sim_probs <- tibble(j = 1:10000) %>%
  mutate(thetas = map(j, ~runif(n = 3, min = 0, max = 1)), 
         gammas = map(thetas, simulate_gammas_from_thetas))
```


## Get Strength and Bounds.

Here, we define the strength of $Z$ on $X$ as $\max_{z_1,z_2} \left | P(X = 1 | Z = z_1) - P(X = 1 | Z = z_2) \right |$, and the strength of $Z$ on $Y$ similarly as $\max_{z_1,z_2} \left | P(Y = 1 | Z = z_1) - P(Y = 1 | Z = z_2) \right |$. 

We then calculate the strength of $Z$ on $X$, $Z$ on $Y$, and find the bounds. 

```{r}
bounds <- sim_probs %>% 
  rowwise() %>% 
  mutate(strength_x = max(abs(outer(thetas, thetas, `-`))),
         strength_y = max(abs(outer(gammas, gammas, `-`))),
         bounds = list(get_bounds(thetas = thetas,
                                  gammas = gammas,
                                  stop = FALSE, 
                                  warning = FALSE))) %>% 
  ungroup() %>% 
  mutate(violations = map_lgl(bounds, "constraints_violated"),
         intervals = map(bounds, "interval")) %>% 
  unnest_wider(intervals) %>% 
  mutate(width = upper - lower)
```

The plot below shows the width plotted against the strength of $Z$ on both $X$ and $Y$. The black line has slope $-2$ and intercept $2$ -- i.e. it represents the upper bound on the width derived under the two monotonicity assumptions. 

```{r}
width_vs_strength <- bounds %>% 
  filter(!violations, upper > lower) %>% 
  ggplot(aes(x = strength_x, y = width)) + 
    geom_point(alpha = 0.2) + 
    geom_abline(slope = -2, intercept = 2) +
    labs(title = "Width of Bivariate Bounds as function of strength",
         x = "Strength of Z on X",
         y = "Width of bounds") + 
    theme_bw()

width_vs_strength
```

```{r}
all_bounds_plot <- bounds %>% 
  filter(!violations, upper > lower) %>% 
  select(contains("strength"), upper, lower) %>% 
  arrange((upper + lower)/2) %>% 
  mutate(id = row_number()) %>% 
  ggplot(aes(x = id, y = (upper + lower)/2)) + 
    geom_line(aes(color = "Center of bounds")) + 
    geom_errorbar(aes(ymin = lower, ymax = upper),
                  width = 0.001, alpha = 0.05) + 
    labs(title = "Bounds from â‰ˆ10,000 randomly generated distributions",
         y = "ACE",
         x = "",
         color = ""
         #caption = paste("Note:", sum(bounds$upper <= bounds$lower), "of the", nrow(bounds), "simulated distributions resulted in upper limits smaller than the lower limits. These have been removed.")
    ) +
    theme_bw() +
    theme(axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank(),
          legend.position = "bottom")

all_bounds_plot
```


As we can see, quite a few of the data

```{r}
proportion_of_widths_greater_than <- bounds %>% 
  #filter(strength_x <= 0.5) %>% 
  group_by(Strength = cut(strength_x, breaks = c(0, 0.05, 0.1, 0.25, 0.5, 1), 
                          include.lowest = TRUE)) %>% 
  summarize(
    w = c(1, 0.75, 0.5),
    #`Proportion with width > w` = map_dbl(c(1, 0.75, 0.5), ~mean(width > .x))
    prop = map_dbl(c(1, 0.75, 0.5), ~mean(width > .x))
  ) %>% 
  mutate(w = glue::glue("w = {w}")) %>% 
  pivot_wider(names_from = w, values_from = prop) %>% print
  
pander::pander(proportion_of_widths_greater_than)
```



```{r}
ggsave(plot = width_vs_strength,
       filename = here::here("figures", "bivariate_width_vs_strength.png"), 
       dpi = 300, width = 7, height = 5)

ggsave(plot = all_bounds_plot,
       filename = here::here("figures", "all_bivariate_bounds.png"),
       dpi = 300, width = 7, height = 5)

write_csv(proportion_of_widths_greater_than,
          path = here::here("tables", "proportion_of_biv_widths_greater_than.csv"))
```



```{r eval = FALSE, include = FALSE}
bounds_w_bpbounds <- bounds %>% 
  filter(lower > upper) %>% 
  rowwise() %>% 
  mutate(bpbounds = list(tidy_bpbounds(bpbounds::bpbounds(p = as.table(rbind(1-gammas, gammas)), 
                                                          t = as.table(rbind(1-thetas, thetas)), 
                                                          fmt = "bivariate")) %>% 
                           filter(Assumption == "IV Inequality", `Causal parameter` == "ACE") %>% 
                           select(assumption_holds = `Assumption Holds`, bplower = `Lower bound`, bpupper = `Upper bound`)))

bounds_w_bpbounds %>% 
  ungroup() %>% 
  unnest(bpbounds) %>% 
  select(j, violations, bp_violations = assumption_holds, contains("lower"), contains("upper")) %>% 
  mutate(bp_violations = !bp_violations) %>% 
  filter(abs(upper - bpupper) > 10e-5) 

sim_zetas <- function(nz){
  zetas <- array(runif(4*nz), dim = c(2,2,nz), dimnames = list(x = 0:1, y = 0:1, z = 0:(nz-1)))
  
  return(zetas / rep(apply(zetas, 3, sum), each = 4))
}

sim_trivariate_probs <- tibble(j = 1:10000) %>%
  mutate(zetas = map(j, ~sim_zetas(nz = 3)))

trivariate_bounds <- sim_trivariate_probs %>% 
  rowwise() %>% 
  mutate(bounds = list(get_bounds(zetas = zetas, stop = FALSE, warning = FALSE)),
         violations = bounds$constraints_violated,
         intervals = list(bounds$interval))


trivariate_bounds %>% 
  ungroup() %>% 
  unnest_wider(intervals) %>% 
  filter(upper < lower) %>% 
  count(violations)
```

