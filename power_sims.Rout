
R version 4.0.2 (2020-06-22) -- "Taking Off Again"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> library(tidyverse)
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.2     ✔ purrr   0.3.4
✔ tibble  3.0.4     ✔ dplyr   1.0.2
✔ tidyr   1.1.2     ✔ stringr 1.4.0
✔ readr   1.4.0     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
> library(ACEBounds)
> library(distributions3)

Attaching package: ‘distributions3’

The following objects are masked from ‘package:stats’:

    Gamma, quantile

The following object is masked from ‘package:grDevices’:

    pdf

> library(furrr)
Loading required package: future
> 
> 
> SIM_AND_SAVE <- TRUE
> PLOT <- TRUE
> OVERWRITE <- TRUE
> 
> ATE_from_simulated_data <- function(from_simulate_data){
+   intercept <- filter(from_simulate_data$coefficients, effect == "Yintercept")$coef
+   x_beta <- filter(from_simulate_data$coefficients, effect == "X_on_Y")$coef
+   u_beta <- filter(from_simulate_data$coefficients, effect == "U_on_Y")$coef
+ 
+   pY1X0 <- 1 / (1 + exp(-intercept - u_beta*from_simulate_data$simulated_data$U))
+   pY1X1 <- 1 / (1 + exp(-intercept - x_beta - u_beta*from_simulate_data$simulated_data$U))
+ 
+   return(mean(pY1X1 - pY1X0))
+ }
> 
> for (K in 2:2){
+ 
+   set.seed(9866311)
+ 
+   if(K == 1){
+     U_on_XY = c(0.1, 0.5)
+   } else {
+     U_on_XY = c(1, 2)
+   }
+ 
+   if(SIM_AND_SAVE){
+     plan(multicore, workers = 3)
+ 
+     Z_on_X <- c(0.25, 0.5, 1, 1.75, seq(2, 4, by = 0.1))
+ 
+     for (i in seq_along(Z_on_X)){
+       cat(i, "of", length(Z_on_X)*2, "\n")
+ 
+ 
+ 
+       many_sims <- expand_grid(indIVs_on_X = Z_on_X[i],
+                                X_on_Y = c(0.25, 0.5, 1, 1.5, 2),
+                                U_on_XY = U_on_XY) %>%
+         mutate(
+           sim_data = future_pmap(
+             .l = list(indIVs_on_X, X_on_Y, U_on_XY),
+             function(x,y,z) simulate_data(
+               sample_size = 1e7,
+               IVs_ps = list(c(0.25, 0.5, 0.25)),
+               X_intercept = -x,
+               Y_intercept = -y/2,
+               indIVs_on_X = x,
+               indIVs_on_Y = 0,
+               U = distributions3::Normal(),
+               U_on_X = z,
+               U_on_Y = z,
+               X_on_Y = y
+             ),
+             .options = furrr_options(seed = TRUE)
+           )
+         )
+ 
+       write_rds(
+         many_sims,
+         here::here("data", paste0("power_sims_", K, "_", str_pad(i, width = 2, side = "left", pad = 0), ".Rds"))
+       )
+     }
+   }
+ }
1 of 50 
2 of 50 
3 of 50 
4 of 50 
5 of 50 
6 of 50 
7 of 50 
8 of 50 
9 of 50 
10 of 50 
11 of 50 
12 of 50 
13 of 50 
14 of 50 
15 of 50 
16 of 50 
17 of 50 
18 of 50 
19 of 50 
20 of 50 
21 of 50 
22 of 50 
23 of 50 
24 of 50 
25 of 50 
> 
> if(PLOT){
+   if(!file.exists(here::here("data/power_bounds_and_ATE.Rds")) | OVERWRITE){
+ 
+   all_power_sims <- list.files(here::here("data"), pattern = "power_sims", full.names = TRUE)
+ 
+   bounds_and_ATE <- tibble(data_file = all_power_sims) %>%
+     mutate(
+       subset = map(
+         data_file,
+         function(x){
+           tmp <- read_rds(x)
+ 
+           out <- tmp %>%
+             mutate(
+               sum_stats = future_map(sim_data, ~c(probs_from_data(.x$simulated_data, X, Y, Z1, data_format = "bivariate"),
+                                                  ATE = ATE_from_simulated_data(.x))),
+               get_bounds_res = future_map(sum_stats, ~get_bounds(gammas = .x$gammas, thetas = .x$thetas, stop = FALSE), .progress = TRUE),
+               bounds = future_map(get_bounds_res, "interval")
+             ) %>%
+             select(-sim_data)
+ 
+           return(out)
+         })
+     )
+ 
+   write_rds(bounds_and_ATE, here::here("data/power_bounds_and_ATE.Rds"))
+ 
+   } else {
+     bounds_and_ATE <- read_rds(here::here("data/power_bounds_and_ATE.Rds"))
+   }
+ 
+   ## Compare indIVs_on_X and resulting strength
+   coefs_vs_strength <- bounds_and_ATE %>%
+     unnest(subset) %>%
+     unnest_wider(sum_stats) %>%
+     unnest_wider(bounds) %>%
+     mutate(strength = map_dbl(thetas, ~.x[3] - .x[1]),
+            U_on_XY = as.character(U_on_XY)) %>%
+     ggplot(aes(y = indIVs_on_X, x = strength,
+                color = U_on_XY)) +
+       geom_line() +
+       scale_x_continuous(limits = c(0, 1)) +
+       scale_y_continuous(limits = c(0, 2.075)*2,
+                          expand = expansion(mult = 0, add = c(0.05, 0.01)*2)) +
+       scale_color_manual(values = c("black", "red")) +
+       labs(color = bquote(gamma[U]),
+            x = "Strength of IV",
+            y = bquote(gamma[Z])) +
+       guides(color = guide_legend(nrow = 2)) +
+       coord_fixed(ratio = 1/4) +
+       theme_bw() +
+       theme(legend.position = "top")
+ 
+   ggsave(here::here("figures/MR_coefs_vs_strength.png"),
+          coefs_vs_strength, dpi = 300,
+          width = 4, height = 4)
+ 
+   ## Bounds Plot
+   pretty_plot <- bounds_and_ATE %>%
+     unnest(subset) %>%
+     unnest_wider(sum_stats) %>%
+     unnest_wider(bounds) %>%
+     mutate(zero = if_else(lower < 0 & upper > 0,
+                           "Overlaps Zero", "Does Not Overlap Zero"),
+            X_on_Y = paste0("beta[X] ==", X_on_Y),
+            U_on_XY = paste0("gamma[U] ==", U_on_XY)) %>%
+     arrange(desc(lower)) %>%
+     ggplot(aes(y = indIVs_on_X, color = zero)) +
+       geom_smooth(se = FALSE, aes(x = upper, group = "loess"), color = "black",
+                   #formula = "x ~ y",
+                   size = 0.2, linetype = "dashed") +
+       geom_smooth(se = FALSE, aes(x = lower, group = "loess"), color = "black",
+                   #formula = "x ~ y",
+                   size = 0.2, linetype = "dashed") +
+       geom_vline(xintercept = 0) +
+       geom_vline(aes(xintercept = ATE, color = "ATE")) +
+       geom_errorbar(aes(xmin = lower, xmax = upper)) +
+       facet_grid(U_on_XY ~ X_on_Y,
+                  labeller = label_parsed) +
+       lims(y = c(0, 4),
+            x = c(-1, 1)) +
+       scale_color_manual(
+         values = c("Overlaps Zero" = "black", "Does Not Overlap Zero" = "red", "ATE" = "blue")
+       ) +
+       labs(
+         y = bquote(gamma[j]),
+         x = "ATE",
+         color = ""
+       ) +
+       theme_bw() +
+       theme(legend.position = "top")
+ 
+   ggsave(here::here("figures/power.png"),
+          plot = pretty_plot, dpi = 300,
+          height = 4, width = 8, units = "in")
+ 
+ 
+   power_curves <- bounds_and_ATE %>%
+     unnest(subset) %>%
+     unnest_wider(sum_stats) %>%
+     unnest_wider(bounds) %>%
+     filter(lower > 0) %>%
+     group_by(U_on_XY, X_on_Y) %>%
+     filter(indIVs_on_X == min(indIVs_on_X)) %>%
+     mutate(U_on_XY = as.character(U_on_XY)) %>%
+     ggplot(aes(x = ATE, y = indIVs_on_X, color = U_on_XY)) +
+       geom_point() + geom_line() +
+       lims(y = c(0, 5),
+            x = c(0, 1)) +
+       labs(
+         x = "Average Treatment Effect",
+         y = bquote(gamma[Z]),
+         color = bquote(gamma[U])
+       ) +
+       scale_color_manual(values = c("black", "red")) +
+       theme_bw() +
+       theme(legend.position = "top")
+ 
+   ggsave(here::here("figures/power_curves.png"),
+          plot = power_curves, dpi = 300,
+          height = 4, width = 4)
+ 
+ 
+   loess_strength <- bounds_and_ATE %>%
+     unnest(subset) %>%
+     unnest_wider(sum_stats) %>%
+     unnest_wider(bounds) %>%
+     mutate(strength = map_dbl(thetas, ~.x[3] - .x[1])) %>%
+     loess(data = .,
+           strength ~ indIVs_on_X + U_on_XY)
+ 
+   uniroot(f = function(x) predict(loess_strength, newdata = data.frame(indIVs_on_X = x, U_on_XY = 0.1)) - 0.5,
+           interval = c(1, 4))
+ 
+   ## Model lower bounds by ATE
+   loess_model <- bounds_and_ATE %>%
+     unnest(subset) %>%
+     unnest_wider(sum_stats) %>%
+     unnest_wider(bounds) %>%
+     loess(data = .,
+           lower ~ indIVs_on_X + X_on_Y + U_on_XY)
+ 
+   ## Show on plot
+   loess_plot <- bounds_and_ATE %>%
+     unnest(subset) %>%
+     unnest_wider(sum_stats) %>%
+     unnest_wider(bounds) %>%
+     ggplot(aes(x = indIVs_on_X, y = lower)) +
+       geom_hline(yintercept = 0, linetype = "dashed") +
+       geom_point() +
+       geom_smooth() +
+       facet_grid(U_on_XY ~ X_on_Y,
+                  labeller = label_both) +
+       lims(y = c(-1, 1)) +
+       labs(
+         x = "Coefficient for effect of Z on X",
+         y = "ATE",
+         color = ""
+       ) +
+       theme_bw() +
+       theme(legend.position = "top")
+ 
+   ggsave(here::here("figures/power_loess_lower_bound.png"),
+          loess_plot, dpi = 300,
+          height = 6, width = 8, units = "in")
+ 
+   ## Find roots for loess curves
+   roots <- bounds_and_ATE %>%
+     unnest(subset) %>%
+     unnest_wider(sum_stats) %>%
+     select(X_on_Y, U_on_XY, ATE) %>%
+     mutate(ATE = round(ATE, digits = 7)) %>%
+     unique() %>%
+     rowwise() %>%
+     mutate(uniroot_res = list(uniroot(f = function(x) predict(loess_model, newdata = data.frame(X_on_Y = X_on_Y, U_on_XY = U_on_XY, indIVs_on_X = x)),
+                                       interval = c(1, 4))),
+            indIVs_on_X = uniroot_res$root) %>%
+     ungroup()
+ 
+ 
+   ## Power curves including for loess model
+   (power_with_loess_ests <- bounds_and_ATE %>%
+     unnest(subset) %>%
+     unnest_wider(sum_stats) %>%
+     unnest_wider(bounds) %>%
+     filter(lower > 0) %>%
+     group_by(U_on_XY, X_on_Y) %>%
+     filter(indIVs_on_X == min(indIVs_on_X)) %>%
+     mutate(source = "simulations") %>%
+     ggplot(aes(x = ATE, y = indIVs_on_X, group = U_on_XY, alpha = source, color = as.character(U_on_XY))) +
+       geom_point() +
+       #geom_line() +
+       #geom_point(data = roots %>% mutate(source = "loess")) +
+       geom_line(data = roots %>% mutate(source = "loess")) +
+       lims(
+         y = c(0, 4),
+         x = c(0, 1)
+       ) +
+       labs(
+         color = bquote(gamma[U]),
+         y = bquote(gamma[Z])
+       ) +
+       scale_color_manual(values = c("black", "red")) +
+       scale_alpha_manual(values = c(1, 0.2)) +
+       guides(
+         color = guide_legend(title.position = "top"),
+         alpha = "none"
+       ) +
+       theme_bw() +
+       theme(legend.position = "top"))
+ 
+   (loess_power <- roots %>%
+       ggplot(aes(x = ATE, y = indIVs_on_X, group = U_on_XY, color = as.character(U_on_XY))) +
+         geom_point() +
+         geom_line() +
+         #geom_point(data = roots %>% mutate(source = "loess")) +
+         lims(
+           y = c(0, 4),
+           x = c(0, 0.5)
+         ) +
+         labs(
+           color = bquote(gamma[U]),
+           y = bquote(gamma[Z])
+         ) +
+         scale_color_manual(values = c("black", "red")) +
+         #scale_alpha_manual(values = c(1, 0.2)) +
+         guides(
+           color = guide_legend(title.position = "top")
+         ) +
+         theme_bw() +
+         theme(legend.position = "top"))
+ 
+   ggsave(here::here("figures/loess_power.png"),
+          loess_power, dpi = 300,
+          height = 5, width = 8)
+ }
Error: Insufficient values in manual scale. 4 needed but only 2 provided.
Backtrace:
     █
  1. └─ggplot2::ggsave(...)
  2.   ├─grid::grid.draw(plot)
  3.   └─ggplot2:::grid.draw.ggplot(plot)
  4.     ├─base::print(x)
  5.     └─ggplot2:::print.ggplot(x)
  6.       ├─ggplot2::ggplot_build(x)
  7.       └─ggplot2:::ggplot_build.ggplot(x)
  8.         └─base::lapply(data, scales_map_df, scales = npscales)
  9.           └─ggplot2:::FUN(X[[i]], ...)
 10.             ├─base::unlist(...)
 11.             └─base::lapply(scales$scales, function(scale) scale$map_df(df = df))
 12.               └─ggplot2:::FUN(X[[i]], ...)
 13.                 └─scale$map_df(df = df)
 14.                   └─ggplot2:::f(..., self = self)
 15.                     └─base::lapply(aesthetics, function(j) self$map(df[[j]]))
 16.                       └─ggplot2:::FUN(X[[i]], ...)
 17.                         └─self$map(df[[j]])
 18.                           └─ggplot2:::f(..., self = self)
 19.                             └─self$palette(n)
 20.                               └─ggplot2:::f(...)
Execution halted
